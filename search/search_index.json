{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AQW Python Documentation","text":"<p>Welcome to the documentation for the AQW automation project. Use the navigation to explore usage guides and API references.</p>"},{"location":"api/commands/","title":"Command Helpers","text":"<p>API reference for the routines defined in <code>core.commands</code>.</p>"},{"location":"api/commands/#core.commands.CombatCommands","title":"<code>CombatCommands</code>","text":"<p>               Bases: <code>_CommandBase</code></p> <p>Combat utilities such as skills and aggro management.</p>"},{"location":"api/commands/#core.commands.CombatCommands.check_is_skill_safe","title":"<code>check_is_skill_safe(skill)</code>","text":"<p>Return whether a skill is safe to use at the current HP threshold.</p> <p>Parameters:</p> Name Type Description Default <code>skill</code> <code>int</code> <p>Skill slot that is about to be executed.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True when the skill can be used safely for the equipped class.</p> Source code in <code>core\\commands\\combat_commands.py</code> <pre><code>def check_is_skill_safe(self, skill: int) -&gt; bool:\n    \"\"\"Return whether a skill is safe to use at the current HP threshold.\n\n    Args:\n        skill (int): Skill slot that is about to be executed.\n\n    Returns:\n        bool: True when the skill can be used safely for the equipped class.\n    \"\"\"\n    conditions = {\n        \"void highlord\": {\n            \"hp_threshold\": 50, # in percentage of current hp from max hp\n            \"skills_to_check\": [1, 3],\n            \"condition\": lambda hp, threshold: hp &lt; threshold\n        },\n        \"scarlet sorceress\": {\n            \"hp_threshold\": 50,\n            \"skills_to_check\": [1, 4],\n            \"condition\": lambda hp, threshold: hp &lt; threshold\n        },\n        \"dragon of time\": {\n            \"hp_threshold\": 40,\n            \"skills_to_check\": [1, 3],\n            \"condition\": lambda hp, threshold: hp &lt; threshold\n        },\n        # \"archpaladin\": {\n        #     \"hp_threshold\": 70,\n        #     \"skills_to_check\": [2],\n        #     \"condition\": lambda hp, threshold: hp &gt; threshold\n        # },\n    }\n    # Get the class and its conditions\n    equipped_class = self.bot.player.get_equipped_item(ItemType.CLASS)\n    if equipped_class:\n        if equipped_class.item_name in conditions:\n            condition = conditions[equipped_class.item_name]\n            current_hp = self.bot.player.CURRENT_HP\n            max_hp = self.bot.player.MAX_HP\n            # Check if the current conditions match\n            if skill in condition[\"skills_to_check\"] and condition[\"condition\"]((current_hp / max_hp) * 100, condition[\"hp_threshold\"]):\n                return False\n    return True\n</code></pre>"},{"location":"api/commands/#core.commands.CombatCommands.do_pwd","title":"<code>do_pwd(monster_id)</code>","text":"<p>Send a raw PWD packet to the server for a specific monster.</p> <p>Parameters:</p> Name Type Description Default <code>monster_id</code> <code>str</code> <p>Monster identifier to include in the packet payload.</p> required <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>The message is sent and no value is returned.</p> Source code in <code>core\\commands\\combat_commands.py</code> <pre><code>@check_alive\ndef do_pwd(self, monster_id: str) -&gt; None:\n    \"\"\"Send a raw PWD packet to the server for a specific monster.\n\n    Args:\n        monster_id (str): Monster identifier to include in the packet payload.\n\n    Returns:\n        None: The message is sent and no value is returned.\n    \"\"\"\n    # %xt%zm%gar%1%3%p6&gt;m:1%wvz%\n    self.bot.write_message(f\"%xt%zm%gar%1%3%p6&gt;m:{monster_id}%wvz%\")\n</code></pre>"},{"location":"api/commands/#core.commands.CombatCommands.get_monster","title":"<code>get_monster(monster)</code>","text":"<p>Return the monster object that matches the provided identifier.</p> <p>Parameters:</p> Name Type Description Default <code>monster</code> <code>str</code> <p>Name or <code>id.X</code> identifier of the monster.</p> required <p>Returns:</p> Type Description <code>Optional[Monster]</code> <p>Monster or None: Monster instance when found, otherwise None.</p> Source code in <code>core\\commands\\combat_commands.py</code> <pre><code>def get_monster(self, monster: str) -&gt; Optional[Monster]:\n    \"\"\"Return the monster object that matches the provided identifier.\n\n    Args:\n        monster (str): Name or ``id.X`` identifier of the monster.\n\n    Returns:\n        Monster or None: Monster instance when found, otherwise None.\n    \"\"\"\n    if monster.startswith('id.'):\n        monster = monster.split('.')[1]\n    for mon in self.bot.monsters:\n        if mon.mon_name.lower() == monster.lower() or mon.mon_map_id == monster:\n            return mon\n    return None\n</code></pre>"},{"location":"api/commands/#core.commands.CombatCommands.get_monster_hp","title":"<code>get_monster_hp(monster)</code>","text":"<p>Get the current HP of the requested monster.</p> <p>Parameters:</p> Name Type Description Default <code>monster</code> <code>str</code> <p>Name or <code>id.X</code> identifier of the monster, <code>*</code> for any.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Current HP, or -1 when the monster is not found.</p> Source code in <code>core\\commands\\combat_commands.py</code> <pre><code>@check_alive\ndef get_monster_hp(self, monster: str) -&gt; int:\n    \"\"\"Get the current HP of the requested monster.\n\n    Args:\n        monster (str): Name or ``id.X`` identifier of the monster, ``*`` for any.\n\n    Returns:\n        int: Current HP, or -1 when the monster is not found.\n    \"\"\"\n    if monster == None:\n        return -1\n    if monster.startswith('id.'):\n        monster = monster.split('.')[1]\n    for mon in self.bot.monsters:\n        if mon.mon_name.lower() == monster.lower() or mon.mon_map_id == monster and mon.is_alive:\n            return mon.current_hp\n        elif monster == \"*\":\n            return mon.current_hp\n    # this mean not get the desired monster\n    return -1\n</code></pre>"},{"location":"api/commands/#core.commands.CombatCommands.get_monster_hp_percentage","title":"<code>get_monster_hp_percentage(monster)</code>","text":"<p>Get the remaining HP of a monster as a percentage.</p> <p>Parameters:</p> Name Type Description Default <code>monster</code> <code>str</code> <p>Name or <code>id.X</code> identifier of the monster, <code>*</code> for any.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Rounded HP percentage, or -1 when the monster is missing.</p> Source code in <code>core\\commands\\combat_commands.py</code> <pre><code>def get_monster_hp_percentage(self, monster: str) -&gt; int:\n    \"\"\"Get the remaining HP of a monster as a percentage.\n\n    Args:\n        monster (str): Name or ``id.X`` identifier of the monster, ``*`` for any.\n\n    Returns:\n        int: Rounded HP percentage, or -1 when the monster is missing.\n    \"\"\"\n    if monster.startswith('id.'):\n        monster = monster.split('.')[1]\n    for mon in self.bot.monsters:\n        if mon.mon_name.lower() == monster.lower() or mon.mon_map_id == monster:\n            return round(((mon.current_hp/mon.max_hp)*100), 2)\n        elif monster == \"*\":\n            return round(((mon.current_hp/mon.max_hp)*100), 2)\n    # this mean not get the desired monster\n    return -1\n</code></pre>"},{"location":"api/commands/#core.commands.CombatCommands.hp_below_percentage","title":"<code>hp_below_percentage(percent)</code>","text":"<p>Check if the player HP is below the requested percentage.</p> <p>Parameters:</p> Name Type Description Default <code>percent</code> <code>int</code> <p>HP threshold to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True when the player HP percentage is lower than the threshold.</p> Source code in <code>core\\commands\\combat_commands.py</code> <pre><code>@check_alive\ndef hp_below_percentage(self, percent: int) -&gt; bool:\n    \"\"\"Check if the player HP is below the requested percentage.\n\n    Args:\n        percent (int): HP threshold to compare against.\n\n    Returns:\n        bool: True when the player HP percentage is lower than the threshold.\n    \"\"\"\n    return ((self.bot.player.CURRENT_HP / self.bot.player.MAX_HP) * 100) &lt; percent\n</code></pre>"},{"location":"api/commands/#core.commands.CombatCommands.is_monster_alive","title":"<code>is_monster_alive(monster='*')</code>","text":"<p>Check whether a monster is alive in the player's current cell.</p> <p>Parameters:</p> Name Type Description Default <code>monster</code> <code>str</code> <p>Name or <code>id.X</code> identifier of the monster, <code>*</code> for any.</p> <code>'*'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True when a matching live monster is found in the cell.</p> Source code in <code>core\\commands\\combat_commands.py</code> <pre><code>def is_monster_alive(self, monster: str = \"*\") -&gt; bool:\n    \"\"\"Check whether a monster is alive in the player's current cell.\n\n    Args:\n        monster (str): Name or ``id.X`` identifier of the monster, ``*`` for any.\n\n    Returns:\n        bool: True when a matching live monster is found in the cell.\n    \"\"\"\n    if monster.startswith('id.'):\n        monster = monster.split('.')[1]\n    for mon in self.bot.monsters:\n        if mon.is_alive and mon.frame == self.bot.player.CELL:\n            if mon.mon_name.lower() == monster.lower() or mon.mon_map_id == monster:\n                return True\n            elif monster == \"*\":\n                return True\n    return False\n</code></pre>"},{"location":"api/commands/#core.commands.CombatCommands.jump_to_monster","title":"<code>jump_to_monster(monsterName, byMostMonster=True, byAliveMonster=False)</code>  <code>async</code>","text":"<p>Jump to the cell that currently hosts the requested monster.</p> <p>Parameters:</p> Name Type Description Default <code>monsterName</code> <code>str</code> <p>Display name or <code>id.X</code> identifier for the monster.</p> required <code>byMostMonster</code> <code>bool</code> <p>Prefer the cell with the highest monster population when True.</p> <code>True</code> <code>byAliveMonster</code> <code>bool</code> <p>Prefer a cell that still has the monster alive when True.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>The coroutine adjusts player position and exits.</p> Source code in <code>core\\commands\\combat_commands.py</code> <pre><code>@check_alive\nasync def jump_to_monster(self, monsterName: str, byMostMonster: bool = True, byAliveMonster: bool = False) -&gt; None:\n    \"\"\"Jump to the cell that currently hosts the requested monster.\n\n    Args:\n        monsterName (str): Display name or ``id.X`` identifier for the monster.\n        byMostMonster (bool): Prefer the cell with the highest monster population when True.\n        byAliveMonster (bool): Prefer a cell that still has the monster alive when True.\n\n    Returns:\n        None: The coroutine adjusts player position and exits.\n    \"\"\"\n    if monsterName.startswith('id.'):\n        monsterName = monsterName.split('.')[1]\n    for monster in self.bot.monsters:\n        if (monster.mon_name.lower() == monsterName.lower() or monster.mon_map_id == monsterName )\\\n                and monster.is_alive \\\n                and self.bot.player.CELL == monster.frame:\n            return\n\n    # Hunt monster in other cell\n    if byMostMonster or byAliveMonster:\n        cell = self.bot.find_best_cell(monsterName, byMostMonster, byAliveMonster)\n        if cell:\n            if cell == self.bot.player.CELL:\n                return\n            self.bot.jump_cell(cell, \"Left\")\n            await asyncio.sleep(1)\n            return\n    for monster in self.bot.monsters:\n        if (monster.mon_name.lower() == monsterName.lower() or monster.mon_map_id == monsterName )\\\n                and monster.is_alive \\\n                and self.bot.player.CELL != monster.frame:\n            # TODO need to handle the rigth pad\n            self.bot.jump_cell(monster.frame, \"Left\")\n            await asyncio.sleep(1)\n            return\n</code></pre>"},{"location":"api/commands/#core.commands.CombatCommands.leave_combat","title":"<code>leave_combat(safeLeave=True)</code>  <code>async</code>","text":"<p>Leave combat and optionally jump back to spawn.</p> <p>Parameters:</p> Name Type Description Default <code>safeLeave</code> <code>bool</code> <p>Jump to the Enter/Spawn cell after leaving combat when True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Always returns None; the bot actions run asynchronously.</p> Source code in <code>core\\commands\\combat_commands.py</code> <pre><code>@check_alive\nasync def leave_combat(self, safeLeave: bool = True) -&gt; None:\n    \"\"\"Leave combat and optionally jump back to spawn.\n\n    Args:\n        safeLeave (bool): Jump to the Enter/Spawn cell after leaving combat when True.\n\n    Returns:\n        None: Always returns None; the bot actions run asynchronously.\n    \"\"\"\n    await self.bot.ensure_leave_from_combat(always=True)\n    if safeLeave:\n        await self.jump_cell(\"Enter\", \"Spawn\")\n</code></pre>"},{"location":"api/commands/#core.commands.CombatCommands.start_aggro","title":"<code>start_aggro(mons_id, delay_ms=500)</code>","text":"<p>Enable the aggro handler for the supplied monster identifiers.</p> <p>Parameters:</p> Name Type Description Default <code>mons_id</code> <code>list[str]</code> <p>Monster identifiers to keep aggroed.</p> required <code>delay_ms</code> <code>int</code> <p>Delay between aggro ticks in milliseconds.</p> <code>500</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Updates the bot state and starts the aggro task.</p> Source code in <code>core\\commands\\combat_commands.py</code> <pre><code>def start_aggro(self, mons_id: list[str], delay_ms: int = 500) -&gt; None:\n    \"\"\"Enable the aggro handler for the supplied monster identifiers.\n\n    Args:\n        mons_id (list[str]): Monster identifiers to keep aggroed.\n        delay_ms (int): Delay between aggro ticks in milliseconds.\n\n    Returns:\n        None: Updates the bot state and starts the aggro task.\n    \"\"\"\n    self.stop_aggro()\n    self.bot.is_aggro_handler_task_running = True\n    self.bot.aggro_mons_id = mons_id\n    self.bot.aggro_delay_ms = delay_ms\n    self.bot.run_aggro_hadler_task()\n</code></pre>"},{"location":"api/commands/#core.commands.CombatCommands.start_aggro_by_cell","title":"<code>start_aggro_by_cell(cells, delay_ms=500)</code>","text":"<p>Start aggroing every monster found in the provided cells.</p> <p>Parameters:</p> Name Type Description Default <code>cells</code> <code>list[str]</code> <p>Cell names to scan for monsters.</p> required <code>delay_ms</code> <code>int</code> <p>Delay between aggro commands in milliseconds.</p> <code>500</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Delegates to start_aggro when monsters are present.</p> Source code in <code>core\\commands\\combat_commands.py</code> <pre><code>def start_aggro_by_cell(self, cells: list[str], delay_ms : int = 500) -&gt; None:\n    \"\"\"Start aggroing every monster found in the provided cells.\n\n    Args:\n        cells (list[str]): Cell names to scan for monsters.\n        delay_ms (int): Delay between aggro commands in milliseconds.\n\n    Returns:\n        None: Delegates to start_aggro when monsters are present.\n    \"\"\"\n    mons_id: list[str] = []\n    for monster in self.bot.monsters:\n        if monster.frame in cells:\n            mons_id.append(str(monster.mon_map_id))\n\n    if len(mons_id) == 0:\n        return\n\n    self.start_aggro(mons_id, delay_ms)\n</code></pre>"},{"location":"api/commands/#core.commands.CombatCommands.stop_aggro","title":"<code>stop_aggro()</code>","text":"<p>Stop the aggro handler and clear tracked monsters.</p> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Clears aggro state without returning a value.</p> Source code in <code>core\\commands\\combat_commands.py</code> <pre><code>def stop_aggro(self) -&gt; None:\n    \"\"\"Stop the aggro handler and clear tracked monsters.\n\n    Returns:\n        None: Clears aggro state without returning a value.\n    \"\"\"\n    self.bot.is_aggro_handler_task_running = False\n    self.bot.aggro_mons_id = []\n</code></pre>"},{"location":"api/commands/#core.commands.CombatCommands.use_skill","title":"<code>use_skill(index=0, target_monsters='*', hunt=False, buff_only=False, reload_delay=500)</code>  <code>async</code>","text":"<p>Execute a skill with optional hunting, targeting, and cooldown handling.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Skill slot that should be triggered.</p> <code>0</code> <code>target_monsters</code> <code>str</code> <p>Target filter, <code>*</code> for any or comma-separated list.</p> <code>'*'</code> <code>hunt</code> <code>bool</code> <p>When True, jump to the monster before casting.</p> <code>False</code> <code>buff_only</code> <code>bool</code> <p>Prevent damaging skills from firing when True.</p> <code>False</code> <code>reload_delay</code> <code>int</code> <p>Cooldown buffer in milliseconds after casting.</p> <code>500</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>The coroutine schedules the skill usage and exits.</p> Source code in <code>core\\commands\\combat_commands.py</code> <pre><code>@check_alive\nasync def use_skill(self,  \n                    index: int = 0, \n                    target_monsters: str = \"*\", \n                    hunt: bool = False, \n                    buff_only: bool = False,\n                    reload_delay: int = 500\n    ) -&gt; None:\n    \"\"\"Execute a skill with optional hunting, targeting, and cooldown handling.\n\n    Args:\n        index (int): Skill slot that should be triggered.\n        target_monsters (str): Target filter, ``*`` for any or comma-separated list.\n        hunt (bool): When True, jump to the monster before casting.\n        buff_only (bool): Prevent damaging skills from firing when True.\n        reload_delay (int): Cooldown buffer in milliseconds after casting.\n\n    Returns:\n        None: The coroutine schedules the skill usage and exits.\n    \"\"\"\n    if not self.bot.player.canUseSkill(int(index)) or not self.check_is_skill_safe(int(index)):\n        return\n\n    skill = self.bot.player.SKILLS[int(index)]\n    self.bot.skillAnim = skill.get(\"anim\", None)\n    max_target = int(skill.get(\"tgtMax\", 1))\n\n    wait_reload_s = (self.skill_reload_time - int(round(datetime.now().timestamp() * 1000))) / 1000\n    if wait_reload_s &gt; 0 and index != 0:\n        # print(Fore.BLUE + f\"[{datetime.now().strftime('%H:%M:%S')}] wait reload skill:{index} cd:{wait_reload_s:.2f} s\" + Fore.RESET)\n        await self.sleep(wait_reload_s*1000)\n\n    if skill[\"tgt\"] == \"h\": \n        priority_monsters_id = []\n        if hunt and len(target_monsters.split(\",\")) == 1 and target_monsters != \"*\":\n            await self.jump_to_monster(target_monsters, byAliveMonster=True)\n        cell_monsters_id = [mon.mon_map_id for mon in self.bot.monsters if mon.frame == self.bot.player.CELL and mon.is_alive]\n        cell_monsters = [mon for mon in self.bot.monsters if mon.frame == self.bot.player.CELL and mon.is_alive]\n        final_ids = []\n        if target_monsters != \"*\":\n            # Mapping priority_monsters_id\n            target_ids = []\n            target_names = []\n            for target_monster in target_monsters.split(','):\n                if target_monster.startswith('id.'):\n                    target_ids.append(target_monster.split('.')[1])\n                else:\n                    target_names.append(target_monster.lower())\n\n            # Step 1: build a map of alive monsters in current cell\n            alive_monsters = {mon.mon_map_id: mon for mon in self.bot.monsters if mon.frame == self.bot.player.CELL and mon.is_alive}\n\n            priority_monsters_id = []\n\n            # Step 2: follow *input* order strictly\n            for target in target_monsters.split(','):\n                if target.startswith(\"id.\"):\n                    mon_id = target.split(\".\")[1]\n                    if mon_id in alive_monsters:\n                        priority_monsters_id.append(mon_id)\n                else:\n                    name = target.lower()\n                    for mon in self.bot.monsters:\n                        if mon.frame == self.bot.player.CELL and mon.is_alive and mon.mon_name.lower() == name:\n                            priority_monsters_id.append(mon.mon_map_id)\n\n            # Step 3: merge into cell_monsters_id (dedup, keep priority first)\n            final_ids = []\n            seen = set()\n\n            # First: priority in order\n            for mon_id in priority_monsters_id:\n                if mon_id not in seen:\n                    final_ids.append(mon_id)\n                    seen.add(mon_id)\n\n            # Then: the rest\n            for mon_id in cell_monsters_id:\n                if mon_id not in seen:\n                    final_ids.append(mon_id)\n                    seen.add(mon_id)\n\n        else:\n            cell_monsters.sort(key=lambda m: m.current_hp)\n            final_ids = [mon.mon_map_id for mon in cell_monsters]\n        if index == 5:\n            self.bot.use_scroll(final_ids, max_target)\n        if index &lt; 5 and len(final_ids) &gt; 0 and not buff_only:\n            self.bot.use_skill_to_monster(\"a\" if index == 0 else index, final_ids, max_target)\n    elif skill[\"tgt\"] == \"f\":\n        self.bot.use_skill_to_player(index, max_target)\n    elif skill[\"tgt\"] == \"s\":\n        self.bot.use_skill_to_myself(index)\n\n    await self.sleep(200)\n    self.bot.player.updateNextUse(index) # do this if skills is REALLY exetuced\n\n    self.skill_reload_time = int(round(datetime.now().timestamp() * 1000)) + reload_delay\n</code></pre>"},{"location":"api/commands/#core.commands.CombatCommands.wait_use_skill","title":"<code>wait_use_skill(index, target_monsters='*')</code>  <code>async</code>","text":"<p>Wait until a skill is ready before casting it.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Skill slot to trigger.</p> required <code>target_monsters</code> <code>str</code> <p>Comma-separated monster names or <code>id.X</code> identifiers to focus.</p> <code>'*'</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>The coroutine finishes once the skill has been used.</p> Source code in <code>core\\commands\\combat_commands.py</code> <pre><code>@check_alive\nasync def wait_use_skill(self, index: int, target_monsters: str = \"*\") -&gt; None:\n    \"\"\"Wait until a skill is ready before casting it.\n\n    Args:\n        index (int): Skill slot to trigger.\n        target_monsters (str): Comma-separated monster names or ``id.X`` identifiers to focus.\n\n    Returns:\n        None: The coroutine finishes once the skill has been used.\n    \"\"\"\n    while not self.bot.player.canUseSkill(int(index)):\n        await self.sleep(100)\n    await self.use_skill(index, target_monsters)\n</code></pre>"},{"location":"api/commands/#core.commands.Command","title":"<code>Command(bot, init_handler=False)</code>","text":"<p>               Bases: <code>QuestCommands</code>, <code>ItemCommands</code>, <code>MapCommands</code>, <code>CombatCommands</code>, <code>PlayerCommands</code>, <code>UtilityCommands</code></p> <p>Facade that exposes quest, item, map, combat, player, and utility helpers.</p> Source code in <code>core\\command.py</code> <pre><code>def __init__(self, bot: \"Bot\", init_handler: bool = False) -&gt; None:\n    self.bot = bot\n\n    self.quest_to_check: int = None\n    self.is_green_quest_var: bool = None\n    self.is_completed_before_var: bool = None\n    self.skill_reload_time: int = 0\n\n    if init_handler:\n        self.bot.subscribe(self._message_handler)\n</code></pre>"},{"location":"api/commands/#core.commands.ItemCommands","title":"<code>ItemCommands</code>","text":"<p>               Bases: <code>_CommandBase</code></p> <p>Inventory, bank, and shop helpers.</p>"},{"location":"api/commands/#core.commands.ItemCommands.add_drop","title":"<code>add_drop(itemName)</code>","text":"<p>Add items to the drop whitelist handled by the bot.</p> <p>Parameters:</p> Name Type Description Default <code>itemName</code> <code>Union[str, List[str]]</code> <p>Single name or list of names to whitelist.</p> required <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Extends the whitelist in place.</p> Source code in <code>core\\commands\\item_commands.py</code> <pre><code>def add_drop(self, itemName: Union[str, List[str]]) -&gt; None:\n    \"\"\"Add items to the drop whitelist handled by the bot.\n\n    Args:\n        itemName (Union[str, List[str]]): Single name or list of names to whitelist.\n\n    Returns:\n        None: Extends the whitelist in place.\n    \"\"\"\n    if isinstance(itemName, str):\n        itemName = [itemName]\n\n    for item in itemName:\n        if item not in self.bot.items_drop_whitelist:\n            self.bot.items_drop_whitelist.append(item)\n</code></pre>"},{"location":"api/commands/#core.commands.ItemCommands.bank_to_inv","title":"<code>bank_to_inv(itemNames)</code>  <code>async</code>","text":"<p>Move items from the bank to the inventory.</p> <p>Parameters:</p> Name Type Description Default <code>itemNames</code> <code>Union[str, List[str]]</code> <p>Single name or list of names to transfer.</p> required <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>The coroutine issues move requests for each item.</p> Source code in <code>core\\commands\\item_commands.py</code> <pre><code>@check_alive\nasync def bank_to_inv(self, itemNames: Union[str, List[str]]) -&gt; None:\n    \"\"\"Move items from the bank to the inventory.\n\n    Args:\n        itemNames (Union[str, List[str]]): Single name or list of names to transfer.\n\n    Returns:\n        None: The coroutine issues move requests for each item.\n    \"\"\"\n    itemNames = itemNames if isinstance(itemNames, list) else [itemNames]\n    for item in itemNames:\n        if not self.is_still_connected():\n            return\n        item = self.bot.player.get_item_bank(item)        \n        if item:\n            packet = f\"%xt%zm%bankToInv%{self.bot.areaId}%{item.item_id}%{item.char_item_id}%\"\n            self.bot.write_message(packet)\n            is_exist = False\n            for itemInv in self.bot.player.INVENTORY:\n                if itemInv.item_name == item.item_name:\n                    self.bot.player.INVENTORY.remove(itemInv)\n                    self.bot.player.INVENTORY.append(item)\n                    is_exist = True\n                    break\n            if not is_exist:\n                self.bot.player.INVENTORY.append(item)\n            for itemBank in self.bot.player.BANK:\n                if itemBank.item_name == item.item_name:\n                    self.bot.player.BANK.remove(itemBank)\n                    break\n            await asyncio.sleep(1)\n</code></pre>"},{"location":"api/commands/#core.commands.ItemCommands.buy_item","title":"<code>buy_item(shop_id, item_name, qty=1)</code>  <code>async</code>","text":"<p>Buy an item, loading the shop if it is not cached.</p> <p>Parameters:</p> Name Type Description Default <code>shop_id</code> <code>int</code> <p>Identifier of the shop containing the item.</p> required <code>item_name</code> <code>str</code> <p>Name of the item to purchase.</p> required <code>qty</code> <code>int</code> <p>Quantity to purchase in a single request.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Sends the buy packet once the shop data is available.</p> Source code in <code>core\\commands\\item_commands.py</code> <pre><code>@check_alive\nasync def buy_item(self, shop_id: int, item_name: str, qty: int = 1) -&gt; None:\n    \"\"\"Buy an item, loading the shop if it is not cached.\n\n    Args:\n        shop_id (int): Identifier of the shop containing the item.\n        item_name (str): Name of the item to purchase.\n        qty (int): Quantity to purchase in a single request.\n\n    Returns:\n        None: Sends the buy packet once the shop data is available.\n    \"\"\"\n    print(f\"buying {qty} {item_name}\")\n    shop: Shop = None\n    for loaded_shop in self.bot.loaded_shop_datas:\n        if str(loaded_shop.shop_id) == str(shop_id):\n            shop = loaded_shop\n            break\n    if shop:\n        for shop_item in shop.items:\n            if shop_item.item_name.lower() == item_name.lower():\n                packet = f\"%xt%zm%buyItem%{self.bot.areaId}%{shop_item.item_id}%{shop.shop_id}%{shop_item.shop_item_id}%{qty}%\"\n                self.bot.write_message(packet)\n                await asyncio.sleep(1)\n                break\n    else:\n        packet = f\"%xt%zm%loadShop%{self.bot.areaId}%{shop_id}%\"\n        self.bot.write_message(packet)\n        await asyncio.sleep(1)\n        await self.buy_item(shop_id, item_name, qty)\n</code></pre>"},{"location":"api/commands/#core.commands.ItemCommands.buy_item_cmd","title":"<code>buy_item_cmd(item_name, shop_id, qty=1)</code>  <code>async</code>","text":"<p>Buy an item from a shop, loading data when necessary.</p> <p>Parameters:</p> Name Type Description Default <code>item_name</code> <code>str</code> <p>Name of the shop item to purchase.</p> required <code>shop_id</code> <code>int</code> <p>Identifier of the shop to query.</p> required <code>qty</code> <code>int</code> <p>Quantity to purchase in a single request.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>The coroutine sends the purchase packet asynchronously.</p> Source code in <code>core\\commands\\item_commands.py</code> <pre><code>async def buy_item_cmd(self, item_name: str, shop_id: int, qty: int = 1) -&gt; None:\n    \"\"\"Buy an item from a shop, loading data when necessary.\n\n    Args:\n        item_name (str): Name of the shop item to purchase.\n        shop_id (int): Identifier of the shop to query.\n        qty (int): Quantity to purchase in a single request.\n\n    Returns:\n        None: The coroutine sends the purchase packet asynchronously.\n    \"\"\"\n    await self.bot.ensure_leave_from_combat()\n    shop = None\n    for loaded_shop in self.bot.loaded_shop_datas:\n        if str(loaded_shop.shop_id) == str(shop_id):\n            shop = loaded_shop\n            break\n    if shop:\n        for shop_item in shop.items:\n            if shop_item.item_name == item_name.lower():\n                packet = f\"%xt%zm%buyItem%{self.bot.areaId}%{shop_item.item_id}%{shop.shop_id}%{shop_item.shop_item_id}%{qty}%\"\n                self.bot.write_message(packet)\n                await asyncio.sleep(0.5)\n                break\n    else:\n        packet = f\"%xt%zm%loadShop%{self.bot.areaId}%{shop_id}%\"\n        self.bot.write_message(packet)\n        await asyncio.sleep(1)\n        self.bot.index -= 1\n</code></pre>"},{"location":"api/commands/#core.commands.ItemCommands.ensure_load_shop","title":"<code>ensure_load_shop(shop_id)</code>  <code>async</code>","text":"<p>Keep loading a shop until it is present in the cache.</p> <p>Parameters:</p> Name Type Description Default <code>shop_id</code> <code>int</code> <p>Identifier of the shop to ensure.</p> required Source code in <code>core\\commands\\item_commands.py</code> <pre><code>@check_alive\nasync def ensure_load_shop(self, shop_id: int) -&gt; None:\n    \"\"\"Keep loading a shop until it is present in the cache.\n\n    Args:\n        shop_id (int): Identifier of the shop to ensure.\n    \"\"\"\n    await self.leave_combat()\n    while True:\n        for loaded_shop in self.bot.loaded_shop_datas:\n            if str(loaded_shop.shop_id) == str(shop_id): \n                print(\"loaded_Shop\", loaded_shop.shop_id)\n                return\n        packet = f\"%xt%zm%loadShop%{self.bot.areaId}%{shop_id}%\"\n        self.bot.write_message(packet)\n        await asyncio.sleep(1)\n</code></pre>"},{"location":"api/commands/#core.commands.ItemCommands.equip_item","title":"<code>equip_item(item_name)</code>  <code>async</code>","text":"<p>Equip an inventory item if it is present and not already equipped.</p> <p>Parameters:</p> Name Type Description Default <code>item_name</code> <code>str</code> <p>Name of the item to equip.</p> required <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Updates the equipped state and sends the equip packet.</p> Source code in <code>core\\commands\\item_commands.py</code> <pre><code>@check_alive\nasync def equip_item(self, item_name: str) -&gt; None:\n    \"\"\"Equip an inventory item if it is present and not already equipped.\n\n    Args:\n        item_name (str): Name of the item to equip.\n\n    Returns:\n        None: Updates the equipped state and sends the equip packet.\n    \"\"\"\n    await self.bot.ensure_leave_from_combat()\n\n    is_equipped = False\n    s_type = None\n    for item in self.bot.player.INVENTORY:\n        if normalize(item.item_name.lower()) == normalize(item_name.lower()):\n            if item.is_equipped:\n                return\n            print(f\"equipping {item_name}\")\n            packet = f\"%xt%zm%equipItem%{self.bot.areaId}%{item.item_id}%\"\n            self.bot.write_message(packet)\n            is_equipped = True\n            s_type = item.s_type\n            item.is_equipped = is_equipped\n            await asyncio.sleep(1)\n            break\n    # Update unequip previous item\n    if is_equipped and s_type:\n        for item in self.bot.player.INVENTORY:\n            if item.s_type == s_type and item.is_equipped and not item.item_name == item_name.lower():\n                item.is_equipped = False\n                break\n</code></pre>"},{"location":"api/commands/#core.commands.ItemCommands.equip_item_by_enhancement","title":"<code>equip_item_by_enhancement(enh_id)</code>  <code>async</code>","text":"<p>Equip the item that matches a specific enhancement identifier.</p> <p>Parameters:</p> Name Type Description Default <code>enh_id</code> <code>int</code> <p>Enhancement identifier bound to the desired item.</p> required <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Calls :meth:<code>equip_item</code> when a matching item exists.</p> Source code in <code>core\\commands\\item_commands.py</code> <pre><code>@check_alive\nasync def equip_item_by_enhancement(self, enh_id: int) -&gt; None:\n    \"\"\"Equip the item that matches a specific enhancement identifier.\n\n    Args:\n        enh_id (int): Enhancement identifier bound to the desired item.\n\n    Returns:\n        None: Calls :meth:`equip_item` when a matching item exists.\n    \"\"\"\n    # TODO: should change the enhance_pattern_id to enhance name\n    item: ItemInventory = self.bot.player.get_item_inventory_by_enhance_id(enh_id)\n    if item:\n        await self.equip_item(item.item_name)\n</code></pre>"},{"location":"api/commands/#core.commands.ItemCommands.equip_scroll","title":"<code>equip_scroll(item_name, item_type=ScrollType.SCROLL)</code>  <code>async</code>","text":"<p>Equip a scroll or potion from the player's inventory.</p> <p>Parameters:</p> Name Type Description Default <code>item_name</code> <code>str</code> <p>Name of the scroll or potion to equip.</p> required <code>item_type</code> <code>ScrollType</code> <p>Scroll category to include in the packet.</p> <code>SCROLL</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Sends the equip packet when the item is found.</p> Source code in <code>core\\commands\\item_commands.py</code> <pre><code>@check_alive\nasync def equip_scroll(self, item_name: str, item_type: ScrollType = ScrollType.SCROLL) -&gt; None:\n    \"\"\"Equip a scroll or potion from the player's inventory.\n\n    Args:\n        item_name (str): Name of the scroll or potion to equip.\n        item_type (ScrollType): Scroll category to include in the packet.\n\n    Returns:\n        None: Sends the equip packet when the item is found.\n    \"\"\"\n    for item in self.bot.player.INVENTORY:\n        if item.item_name.lower() == item_name.lower():\n            packet = f\"%xt%zm%geia%{self.bot.areaId}%{item_type.value}%{item.s_meta}%{item.item_id}%\"\n            self.bot.scroll_id = item.item_id\n            self.bot.write_message(packet)\n            await asyncio.sleep(1)\n            break\n</code></pre>"},{"location":"api/commands/#core.commands.ItemCommands.farming_logger","title":"<code>farming_logger(item_name, item_qty=1, is_temp=False)</code>","text":"<p>Log farming progress for a specific item.</p> <p>Parameters:</p> Name Type Description Default <code>item_name</code> <code>str</code> <p>Name of the item being farmed.</p> required <code>item_qty</code> <code>int</code> <p>Target quantity for the farming session.</p> <code>1</code> <code>is_temp</code> <code>bool</code> <p>Whether to read from the temporary inventory.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Prints progress information to the console.</p> Source code in <code>core\\commands\\item_commands.py</code> <pre><code>def farming_logger(self, item_name: str, item_qty: int = 1, is_temp: bool = False) -&gt; None:\n    \"\"\"Log farming progress for a specific item.\n\n    Args:\n        item_name (str): Name of the item being farmed.\n        item_qty (int): Target quantity for the farming session.\n        is_temp (bool): Whether to read from the temporary inventory.\n\n    Returns:\n        None: Prints progress information to the console.\n    \"\"\"\n    # Determine inventory type and fetch the item\n    inventory_type = \"temp\" if is_temp else \"inv\"\n    get_inventory = (\n        self.bot.player.get_item_temp_inventory\n        if is_temp else self.bot.player.get_item_inventory\n    )\n\n    # Fetch the item\n    item = get_inventory(item_name)\n    inv_item_qty = item.qty if item else 0\n\n    # Prepare log message\n    current_time = datetime.now().strftime('%H:%M:%S')\n    message = (\n        f\"{Fore.CYAN}[{current_time}] [{inventory_type}] {item_name} \"\n        f\"{inv_item_qty}/{item_qty}{Fore.RESET}\"\n    )\n\n    # Print log message\n    print(message)\n</code></pre>"},{"location":"api/commands/#core.commands.ItemCommands.get_loaded_shop","title":"<code>get_loaded_shop(shop_id)</code>","text":"<p>Return a loaded shop instance when available.</p> <p>Parameters:</p> Name Type Description Default <code>shop_id</code> <code>int</code> <p>Identifier of the shop to look up.</p> required <p>Returns:</p> Type Description <code>Shop</code> <p>Shop | None: Cached shop instance, or None if it has not been loaded.</p> Source code in <code>core\\commands\\item_commands.py</code> <pre><code>@check_alive\ndef get_loaded_shop(self, shop_id: int) -&gt; Shop:\n    \"\"\"Return a loaded shop instance when available.\n\n    Args:\n        shop_id (int): Identifier of the shop to look up.\n\n    Returns:\n        Shop | None: Cached shop instance, or None if it has not been loaded.\n    \"\"\"\n    for loaded_shop in self.bot.loaded_shop_datas:\n        if str(loaded_shop.shop_id) == str(shop_id): \n            return loaded_shop\n    return None\n</code></pre>"},{"location":"api/commands/#core.commands.ItemCommands.get_map_item","title":"<code>get_map_item(map_item_id, qty=1)</code>  <code>async</code>","text":"<p>Collect a map item multiple times.</p> <p>Parameters:</p> Name Type Description Default <code>map_item_id</code> <code>int</code> <p>Map item identifier to pick up.</p> required <code>qty</code> <code>int</code> <p>Number of pickup attempts.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Sends the pickup packet for each requested iteration.</p> Source code in <code>core\\commands\\item_commands.py</code> <pre><code>@check_alive\nasync def get_map_item(self, map_item_id: int, qty: int = 1) -&gt; None:\n    \"\"\"Collect a map item multiple times.\n\n    Args:\n        map_item_id (int): Map item identifier to pick up.\n        qty (int): Number of pickup attempts.\n\n    Returns:\n        None: Sends the pickup packet for each requested iteration.\n    \"\"\"\n    for _ in range(qty):\n        self.bot.write_message(f\"%xt%zm%getMapItem%{self.bot.areaId}%{map_item_id}%\")\n        await asyncio.sleep(1)\n</code></pre>"},{"location":"api/commands/#core.commands.ItemCommands.get_quant_item","title":"<code>get_quant_item(itemName)</code>","text":"<p>Return the current quantity of an item in the inventory.</p> <p>Parameters:</p> Name Type Description Default <code>itemName</code> <code>str</code> <p>Name of the inventory item.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Quantity of the item, or 0 when the item is missing.</p> Source code in <code>core\\commands\\item_commands.py</code> <pre><code>def get_quant_item(self, itemName: str) -&gt; int:\n    \"\"\"Return the current quantity of an item in the inventory.\n\n    Args:\n        itemName (str): Name of the inventory item.\n\n    Returns:\n        int: Quantity of the item, or 0 when the item is missing.\n    \"\"\"\n    # get item quant from inventory\n    item_inventory: ItemInventory = self.bot.player.get_item_inventory(itemName)\n    if item_inventory:\n        return item_inventory.qty\n    return 0\n</code></pre>"},{"location":"api/commands/#core.commands.ItemCommands.inv_to_bank","title":"<code>inv_to_bank(itemNames)</code>  <code>async</code>","text":"<p>Move items from the inventory to the bank.</p> <p>Parameters:</p> Name Type Description Default <code>itemNames</code> <code>Union[str, List[str]]</code> <p>Single name or list of names to transfer.</p> required <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>The coroutine issues transfer packets for each item.</p> Source code in <code>core\\commands\\item_commands.py</code> <pre><code>@check_alive\nasync def inv_to_bank(self, itemNames: Union[str, List[str]]) -&gt; None:\n    \"\"\"Move items from the inventory to the bank.\n\n    Args:\n        itemNames (Union[str, List[str]]): Single name or list of names to transfer.\n\n    Returns:\n        None: The coroutine issues transfer packets for each item.\n    \"\"\"\n    await self.leave_combat()\n    itemNames = itemNames if isinstance(itemNames, list) else [itemNames]\n    for item in itemNames:\n        if not self.is_still_connected():\n            return\n        item = self.bot.player.get_item_inventory(item)        \n        if item:\n            packet = f\"%xt%zm%bankFromInv%{self.bot.areaId}%{item.item_id}%{item.char_item_id}%\"\n            self.bot.write_message(packet)\n            is_exist = False\n            for itemBank in self.bot.player.BANK:\n                if itemBank.item_name == item.item_name:\n                    self.bot.player.BANK.remove(itemBank)\n                    self.bot.player.BANK.append(item)\n                    is_exist = True\n                    break\n            if not is_exist:\n                self.bot.player.BANK.append(item)\n            for itemInv in self.bot.player.INVENTORY:\n                if itemInv.item_name == item.item_name:\n                    self.bot.player.INVENTORY.remove(itemInv)\n                    break\n            await asyncio.sleep(1)\n</code></pre>"},{"location":"api/commands/#core.commands.ItemCommands.is_in_bank","title":"<code>is_in_bank(itemName, itemQty=1, operator='&gt;=')</code>","text":"<p>Check whether the bank holds a given quantity of an item.</p> <p>Parameters:</p> Name Type Description Default <code>itemName</code> <code>str</code> <p>Name of the item to inspect.</p> required <code>itemQty</code> <code>int</code> <p>Quantity threshold to test.</p> <code>1</code> <code>operator</code> <code>str</code> <p>Comparison operator understood by the bot API.</p> <code>'&gt;='</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True when the bank fulfils the requested quantity test.</p> Source code in <code>core\\commands\\item_commands.py</code> <pre><code>def is_in_bank(self, itemName: str, itemQty: int = 1, operator: str = \"&gt;=\") -&gt; bool:\n    \"\"\"Check whether the bank holds a given quantity of an item.\n\n    Args:\n        itemName (str): Name of the item to inspect.\n        itemQty (int): Quantity threshold to test.\n        operator (str): Comparison operator understood by the bot API.\n\n    Returns:\n        bool: True when the bank fulfils the requested quantity test.\n    \"\"\"\n    inBank = self.bot.player.isInBank(itemName, itemQty, operator)\n    return inBank[0]\n</code></pre>"},{"location":"api/commands/#core.commands.ItemCommands.is_in_inventory","title":"<code>is_in_inventory(itemName, itemQty=1, operator='&gt;=', isTemp=False)</code>","text":"<p>Check whether the inventory (temp or permanent) has enough items.</p> <p>Parameters:</p> Name Type Description Default <code>itemName</code> <code>str</code> <p>Name of the item to inspect.</p> required <code>itemQty</code> <code>int</code> <p>Quantity threshold to test.</p> <code>1</code> <code>operator</code> <code>str</code> <p>Comparison operator understood by the bot API.</p> <code>'&gt;='</code> <code>isTemp</code> <code>bool</code> <p>When True, inspect the temporary inventory.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True when the inventory satisfies the quantity requirement.</p> Source code in <code>core\\commands\\item_commands.py</code> <pre><code>def is_in_inventory(self, itemName: str, itemQty: int = 1, operator: str = \"&gt;=\", isTemp: bool = False) -&gt; bool:\n    \"\"\"Check whether the inventory (temp or permanent) has enough items.\n\n    Args:\n        itemName (str): Name of the item to inspect.\n        itemQty (int): Quantity threshold to test.\n        operator (str): Comparison operator understood by the bot API.\n        isTemp (bool): When True, inspect the temporary inventory.\n\n    Returns:\n        bool: True when the inventory satisfies the quantity requirement.\n    \"\"\"\n    inInv = self.bot.player.isInInventory(itemName, itemQty, operator, isTemp)\n    return inInv[0]\n</code></pre>"},{"location":"api/commands/#core.commands.ItemCommands.is_in_inventory_or_bank","title":"<code>is_in_inventory_or_bank(itemName, itemQty=1, operator='&gt;=', isTemp=False)</code>","text":"<p>Check whether an item is available in bank or inventory.</p> <p>Parameters:</p> Name Type Description Default <code>itemName</code> <code>str</code> <p>Name of the item to inspect.</p> required <code>itemQty</code> <code>int</code> <p>Quantity threshold to test.</p> <code>1</code> <code>operator</code> <code>str</code> <p>Comparison operator understood by the bot API.</p> <code>'&gt;='</code> <code>isTemp</code> <code>bool</code> <p>When True, include the temporary inventory.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True when either storage location satisfies the check.</p> Source code in <code>core\\commands\\item_commands.py</code> <pre><code>def is_in_inventory_or_bank(self, itemName: str, itemQty: int = 1, operator: str = \"&gt;=\", isTemp: bool = False) -&gt; bool:\n    \"\"\"Check whether an item is available in bank or inventory.\n\n    Args:\n        itemName (str): Name of the item to inspect.\n        itemQty (int): Quantity threshold to test.\n        operator (str): Comparison operator understood by the bot API.\n        isTemp (bool): When True, include the temporary inventory.\n\n    Returns:\n        bool: True when either storage location satisfies the check.\n    \"\"\"\n    return self.is_in_bank(itemName, itemQty, operator) or self.is_in_inventory(itemName, itemQty, operator, isTemp)\n</code></pre>"},{"location":"api/commands/#core.commands.ItemCommands.load_shop","title":"<code>load_shop(shop_id)</code>  <code>async</code>","text":"<p>Request shop data from the server and wait for the response.</p> <p>Parameters:</p> Name Type Description Default <code>shop_id</code> <code>int</code> <p>Identifier of the shop to load.</p> required <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Awaits for a short delay to let the data load.</p> Source code in <code>core\\commands\\item_commands.py</code> <pre><code>@check_alive\nasync def load_shop(self, shop_id: int) -&gt; None:\n    \"\"\"Request shop data from the server and wait for the response.\n\n    Args:\n        shop_id (int): Identifier of the shop to load.\n\n    Returns:\n        None: Awaits for a short delay to let the data load.\n    \"\"\"\n    msg = f\"%xt%zm%loadShop%{self.bot.areaId}%{shop_id}%\"\n    self.bot.write_message(msg)\n    await self.sleep(1000)\n</code></pre>"},{"location":"api/commands/#core.commands.ItemCommands.sell_item","title":"<code>sell_item(item_name, qty=1)</code>  <code>async</code>","text":"<p>Sell an item from the inventory.</p> <p>Parameters:</p> Name Type Description Default <code>item_name</code> <code>str</code> <p>Name of the item to sell.</p> required <code>qty</code> <code>int</code> <p>Quantity to sell in a single transaction.</p> <code>1</code> Source code in <code>core\\commands\\item_commands.py</code> <pre><code>@check_alive\nasync def sell_item(self, item_name: str, qty: int = 1) -&gt; None:\n    \"\"\"Sell an item from the inventory.\n\n    Args:\n        item_name (str): Name of the item to sell.\n        qty (int): Quantity to sell in a single transaction.\n\n    \"\"\"\n    # %xt%zm%sellItem%374121%87406%1%950679343%\n    item: ItemInventory = self.bot.player.get_item_inventory(item_name)\n    if item:\n        self.bot.debug(f\"Selling {qty}x {item_name}...\")\n        self.bot.write_message(f\"%xt%zm%sellItem%{self.bot.areaId}%{item.item_id}%{qty}%{item.char_item_id}%\")\n        await self.sleep(500)\n</code></pre>"},{"location":"api/commands/#core.commands.MapCommands","title":"<code>MapCommands</code>","text":"<p>               Bases: <code>_CommandBase</code></p> <p>Map travel and positioning helpers.</p>"},{"location":"api/commands/#core.commands.MapCommands.goto_player","title":"<code>goto_player(player_name)</code>  <code>async</code>","text":"<p>Jump to another player on the current server.</p> <p>Parameters:</p> Name Type Description Default <code>player_name</code> <code>str</code> <p>Target player name to follow.</p> required Source code in <code>core\\commands\\map_commands.py</code> <pre><code>@check_alive\nasync def goto_player(self, player_name: str) -&gt; None:\n    \"\"\"Jump to another player on the current server.\n\n    Args:\n        player_name (str): Target player name to follow.\n    \"\"\"\n    await self.bot.ensure_leave_from_combat(always=True)\n    self.bot.write_message(f\"%xt%zm%cmd%1%goto%{player_name}%\")\n    await self.sleep(1000)\n</code></pre>"},{"location":"api/commands/#core.commands.MapCommands.is_not_in_cell","title":"<code>is_not_in_cell(cell)</code>","text":"<p>Check whether the player is standing in a different cell.</p> <p>Parameters:</p> Name Type Description Default <code>cell</code> <code>str</code> <p>Cell name to compare with the current position.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True when the active cell does not match <code>cell</code>.</p> Source code in <code>core\\commands\\map_commands.py</code> <pre><code>def is_not_in_cell(self, cell: str) -&gt; bool:\n    \"\"\"Check whether the player is standing in a different cell.\n\n    Args:\n        cell (str): Cell name to compare with the current position.\n\n    Returns:\n        bool: True when the active cell does not match ``cell``.\n    \"\"\"\n    return self.bot.player.CELL.lower() != cell.lower()\n</code></pre>"},{"location":"api/commands/#core.commands.MapCommands.is_not_in_map","title":"<code>is_not_in_map(mapName)</code>","text":"<p>Return True when the player is not currently in the given map.</p> <p>Parameters:</p> Name Type Description Default <code>mapName</code> <code>str</code> <p>Map identifier to compare.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True when the current map differs from <code>mapName</code>.</p> Source code in <code>core\\commands\\map_commands.py</code> <pre><code>def is_not_in_map(self, mapName: str) -&gt; bool:\n    \"\"\"Return True when the player is not currently in the given map.\n\n    Args:\n        mapName (str): Map identifier to compare.\n\n    Returns:\n        bool: True when the current map differs from ``mapName``.\n    \"\"\"\n    return mapName.lower() != self.bot.strMapName.lower()\n</code></pre>"},{"location":"api/commands/#core.commands.MapCommands.join_house","title":"<code>join_house(houseName, safeLeave=True)</code>  <code>async</code>","text":"<p>Join a player house while optionally leaving combat safely.</p> <p>Parameters:</p> Name Type Description Default <code>houseName</code> <code>str</code> <p>Name of the house to join.</p> required <code>safeLeave</code> <code>bool</code> <p>Leave combat via spawn before issuing the join request.</p> <code>True</code> Source code in <code>core\\commands\\map_commands.py</code> <pre><code>@check_alive\nasync def join_house(self, houseName: str, safeLeave: bool = True) -&gt; None:\n    \"\"\"Join a player house while optionally leaving combat safely.\n\n    Args:\n        houseName (str): Name of the house to join.\n        safeLeave (bool): Leave combat via spawn before issuing the join request.\n    \"\"\"\n    self.stop_aggro()\n    if self.bot.strMapName.lower() == houseName.lower():\n        return\n    self.bot.is_joining_map = True\n    await self.leave_combat(safeLeave)\n    msg = f\"%xt%zm%house%1%{houseName}%\"\n    self.bot.write_message(msg)\n</code></pre>"},{"location":"api/commands/#core.commands.MapCommands.join_map","title":"<code>join_map(mapName, roomNumber=None, safeLeave=True)</code>  <code>async</code>","text":"<p>Join a map instance, picking the appropriate room.</p> <p>Parameters:</p> Name Type Description Default <code>mapName</code> <code>str</code> <p>Map identifier to join.</p> required <code>roomNumber</code> <code>int | None</code> <p>Specific room number to target when provided.</p> <code>None</code> <code>safeLeave</code> <code>bool</code> <p>Leave combat before transferring maps.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Records join state and sends the transfer packet.</p> Source code in <code>core\\commands\\map_commands.py</code> <pre><code>@check_alive\nasync def join_map(self, mapName: str, roomNumber: int = None, safeLeave: bool = True) -&gt; None:\n    \"\"\"Join a map instance, picking the appropriate room.\n\n    Args:\n        mapName (str): Map identifier to join.\n        roomNumber (int | None): Specific room number to target when provided.\n        safeLeave (bool): Leave combat before transferring maps.\n\n    Returns:\n        None: Records join state and sends the transfer packet.\n    \"\"\"\n    self.stop_aggro()\n    if self.bot.strMapName.lower() == mapName.lower():\n        return\n    self.bot.is_joining_map = True\n    await self.leave_combat(safeLeave)\n\n    if roomNumber != None:\n        msg = f\"%xt%zm%cmd%1%tfer%{self.bot.player.USER}%{mapName}-{roomNumber}%\"\n    elif self.bot.roomNumber != None:\n        roomNumber = self.bot.roomNumber\n        msg = f\"%xt%zm%cmd%1%tfer%{self.bot.player.USER}%{mapName}-{self.bot.roomNumber}%\"\n    else:\n        msg = f\"%xt%zm%cmd%1%tfer%{self.bot.player.USER}%{mapName}%\"\n    self.bot.write_message(msg)\n</code></pre>"},{"location":"api/commands/#core.commands.MapCommands.jump_cell","title":"<code>jump_cell(cell, pad)</code>  <code>async</code>","text":"<p>Jump to a specific cell and pad if not already positioned there.</p> <p>Parameters:</p> Name Type Description Default <code>cell</code> <code>str</code> <p>Cell name to move to.</p> required <code>pad</code> <code>str</code> <p>Pad identifier within the cell.</p> required <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Executes a jump command and waits briefly for sync.</p> Source code in <code>core\\commands\\map_commands.py</code> <pre><code>@check_alive\nasync def jump_cell(self, cell: str, pad: str) -&gt; None:\n    \"\"\"Jump to a specific cell and pad if not already positioned there.\n\n    Args:\n        cell (str): Cell name to move to.\n        pad (str): Pad identifier within the cell.\n\n    Returns:\n        None: Executes a jump command and waits briefly for sync.\n    \"\"\"\n    if self.bot.player.CELL.lower() != cell.lower() or self.bot.player.PAD.lower() != pad.lower():\n        self.bot.jump_cell(cell, pad)\n        #print(f\"jump cell: {cell} {pad}\")\n        await asyncio.sleep(1)\n</code></pre>"},{"location":"api/commands/#core.commands.MapCommands.walk_to","title":"<code>walk_to(X, Y, speed=8)</code>  <code>async</code>","text":"<p>Walk to a coordinate within the current map.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>int</code> <p>Target X coordinate.</p> required <code>Y</code> <code>int</code> <p>Target Y coordinate.</p> required <code>speed</code> <code>int</code> <p>Movement speed for the walk animation.</p> <code>8</code> Source code in <code>core\\commands\\map_commands.py</code> <pre><code>@check_alive\nasync def walk_to(self, X: int, Y: int, speed: int = 8) -&gt; None:\n    \"\"\"Walk to a coordinate within the current map.\n\n    Args:\n        X (int): Target X coordinate.\n        Y (int): Target Y coordinate.\n        speed (int): Movement speed for the walk animation.\"\"\"\n    await self.bot.walk_to(X, Y, speed)\n    await self.sleep(200)\n</code></pre>"},{"location":"api/commands/#core.commands.PlayerCommands","title":"<code>PlayerCommands</code>","text":"<p>               Bases: <code>_CommandBase</code></p> <p>Player state inspection helpers.</p>"},{"location":"api/commands/#core.commands.PlayerCommands.get_equipped_class","title":"<code>get_equipped_class()</code>","text":"<p>Return the currently equipped class inventory item, or None.</p> Source code in <code>core\\commands\\player_commands.py</code> <pre><code>def get_equipped_class(self) -&gt; Optional[ItemInventory]:\n    \"\"\"Return the currently equipped class inventory item, or None.\"\"\"\n    equipped_class = self.bot.player.get_equipped_item(ItemType.CLASS)\n    return equipped_class if equipped_class else None\n</code></pre>"},{"location":"api/commands/#core.commands.PlayerCommands.get_farm_class","title":"<code>get_farm_class()</code>","text":"<p>Return the configured farming class name, or None when unset.</p> Source code in <code>core\\commands\\player_commands.py</code> <pre><code>def get_farm_class(self) -&gt; Optional[str]:\n    \"\"\"Return the configured farming class name, or None when unset.\"\"\"\n    return None if self.bot.farmClass == \"\" else self.bot.farmClass\n</code></pre>"},{"location":"api/commands/#core.commands.PlayerCommands.get_player","title":"<code>get_player()</code>","text":"<p>Return the bot's active player instance.</p> Source code in <code>core\\commands\\player_commands.py</code> <pre><code>def get_player(self) -&gt; Player:\n    \"\"\"Return the bot's active player instance.\"\"\"\n    return self.bot.player\n</code></pre>"},{"location":"api/commands/#core.commands.PlayerCommands.get_player_cell","title":"<code>get_player_cell()</code>","text":"<p>Return the local player's current cell name.</p> Source code in <code>core\\commands\\player_commands.py</code> <pre><code>def get_player_cell(self) -&gt; str:\n    \"\"\"Return the local player's current cell name.\"\"\"\n    return self.bot.player.getPlayerCell()[0]\n</code></pre>"},{"location":"api/commands/#core.commands.PlayerCommands.get_player_in_map","title":"<code>get_player_in_map(name)</code>","text":"<p>Return the area record for a player in the current map, if present.</p> Source code in <code>core\\commands\\player_commands.py</code> <pre><code>def get_player_in_map(self, name: str) -&gt; Optional[PlayerArea]:\n    \"\"\"Return the area record for a player in the current map, if present.\"\"\"\n    for player in self.bot.player_in_area:\n        if player.str_username.lower() == name.lower():\n            return player\n    return None\n</code></pre>"},{"location":"api/commands/#core.commands.PlayerCommands.get_player_pad","title":"<code>get_player_pad()</code>","text":"<p>Return the local player's current pad identifier.</p> Source code in <code>core\\commands\\player_commands.py</code> <pre><code>def get_player_pad(self) -&gt; str:\n    \"\"\"Return the local player's current pad identifier.\"\"\"\n    return self.bot.player.getPlayerCell()[1]\n</code></pre>"},{"location":"api/commands/#core.commands.PlayerCommands.get_player_position_xy","title":"<code>get_player_position_xy()</code>","text":"<p>Return the local player's map coordinates as an [x, y] list.</p> Source code in <code>core\\commands\\player_commands.py</code> <pre><code>def get_player_position_xy(self) -&gt; list[int]:\n    \"\"\"Return the local player's map coordinates as an [x, y] list.\"\"\"\n    return self.bot.player.getPlayerPositionXY()\n</code></pre>"},{"location":"api/commands/#core.commands.PlayerCommands.get_solo_class","title":"<code>get_solo_class()</code>","text":"<p>Return the configured solo class name, or None when unset.</p> Source code in <code>core\\commands\\player_commands.py</code> <pre><code>def get_solo_class(self) -&gt; Optional[str]:\n    \"\"\"Return the configured solo class name, or None when unset.\"\"\"\n    return None if self.bot.soloClass == \"\" else self.bot.soloClass\n</code></pre>"},{"location":"api/commands/#core.commands.PlayerCommands.is_player_alive","title":"<code>is_player_alive()</code>","text":"<p>Return True when the local player is not dead.</p> Source code in <code>core\\commands\\player_commands.py</code> <pre><code>def is_player_alive(self) -&gt; bool:\n    \"\"\"Return True when the local player is not dead.\"\"\"\n    return not self.bot.player.ISDEAD\n</code></pre>"},{"location":"api/commands/#core.commands.PlayerCommands.is_player_in_cell","title":"<code>is_player_in_cell(name, cell)</code>","text":"<p>Return True when a named player is currently in the given cell.</p> Source code in <code>core\\commands\\player_commands.py</code> <pre><code>def is_player_in_cell(self, name: str, cell: str) -&gt; bool:\n    \"\"\"Return True when a named player is currently in the given cell.\"\"\"\n    player = self.get_player_in_map(name)\n    if player and player.str_frame and player.str_frame.lower() == cell.lower():\n        return True\n    return False\n</code></pre>"},{"location":"api/commands/#core.commands.PlayerCommands.is_still_connected","title":"<code>is_still_connected()</code>","text":"<p>Check whether the client connection is still active.</p> Source code in <code>core\\commands\\player_commands.py</code> <pre><code>def is_still_connected(self) -&gt; bool:\n    \"\"\"Check whether the client connection is still active.\"\"\"\n    return self.bot.is_client_connected\n</code></pre>"},{"location":"api/commands/#core.commands.PlayerCommands.wait_count_player","title":"<code>wait_count_player(player_count)</code>","text":"<p>Check if the current map has at least the requested player count.</p> Source code in <code>core\\commands\\player_commands.py</code> <pre><code>def wait_count_player(self, player_count: int) -&gt; bool:\n    \"\"\"Check if the current map has at least the requested player count.\"\"\"\n    return len(self.bot.user_ids) &gt;= player_count\n</code></pre>"},{"location":"api/commands/#core.commands.PlayerCommands.wait_count_player_in_cell","title":"<code>wait_count_player_in_cell(cell, player_count)</code>","text":"<p>Check if a cell hosts at least the requested number of players.</p> Source code in <code>core\\commands\\player_commands.py</code> <pre><code>def wait_count_player_in_cell(self, cell: str, player_count: int) -&gt; bool:\n    \"\"\"Check if a cell hosts at least the requested number of players.\"\"\"\n    count = 0\n    cell = cell.lower()\n    for player in self.bot.player_in_area:\n        print(player.str_username, player.str_frame, cell)\n        if player.str_frame.lower() == cell:\n            count += 1\n\n    if self.bot.player.CELL.lower() == cell:\n        count += 1\n    return count &gt;= player_count\n</code></pre>"},{"location":"api/commands/#core.commands.QuestCommands","title":"<code>QuestCommands</code>","text":"<p>               Bases: <code>_CommandBase</code></p> <p>Quest-related automation helpers.</p>"},{"location":"api/commands/#core.commands.QuestCommands.accept_quest","title":"<code>accept_quest(quest_id)</code>  <code>async</code>","text":"<p>Send a single quest accept packet and wait briefly for the response.</p> <p>Parameters:</p> Name Type Description Default <code>quest_id</code> <code>int</code> <p>Identifier of the quest to accept.</p> required <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>The coroutine simply delays to allow server processing.</p> Source code in <code>core\\commands\\quest_commands.py</code> <pre><code>@check_alive\nasync def accept_quest(self, quest_id: int) -&gt; None:\n    \"\"\"Send a single quest accept packet and wait briefly for the response.\n\n    Args:\n        quest_id (int): Identifier of the quest to accept.\n\n    Returns:\n        None: The coroutine simply delays to allow server processing.\"\"\"\n    self.bot.accept_quest(quest_id)\n    print(\"trying accept quest:\", quest_id)\n    await asyncio.sleep(1)\n</code></pre>"},{"location":"api/commands/#core.commands.QuestCommands.accept_quest_bulk","title":"<code>accept_quest_bulk(quest_id, increment, ensure=False)</code>  <code>async</code>","text":"<p>Accept a range of quests sequentially.</p> <p>Parameters:</p> Name Type Description Default <code>quest_id</code> <code>int</code> <p>Starting quest identifier.</p> required <code>increment</code> <code>int</code> <p>Number of consecutive quest ids to process.</p> required <code>ensure</code> <code>bool</code> <p>Use ensure-accept logic for each quest when True.</p> <code>False</code> Source code in <code>core\\commands\\quest_commands.py</code> <pre><code>@check_alive\nasync def accept_quest_bulk(self, quest_id: int, increment: int, ensure:bool = False):\n    \"\"\"Accept a range of quests sequentially.\n\n    Args:\n        quest_id (int): Starting quest identifier.\n        increment (int): Number of consecutive quest ids to process.\n        ensure (bool): Use ensure-accept logic for each quest when True.\"\"\"\n    print(f\"accepting quest from {quest_id} to {quest_id + increment}\")\n    for i in range(increment):\n        if ensure:\n            await self.ensure_accept_quest(quest_id + i)\n        elif not ensure:\n            await self.accept_quest(quest_id + i)\n</code></pre>"},{"location":"api/commands/#core.commands.QuestCommands.can_turnin_quest","title":"<code>can_turnin_quest(questId)</code>","text":"<p>Delegate to the bot helper that checks quest completion requirements.</p> Source code in <code>core\\commands\\quest_commands.py</code> <pre><code>def can_turnin_quest(self, questId: int) -&gt; bool:\n    \"\"\"Delegate to the bot helper that checks quest completion requirements.\"\"\"\n    return self.bot.can_turn_in_quest(questId)\n</code></pre>"},{"location":"api/commands/#core.commands.QuestCommands.ensure_accept_quest","title":"<code>ensure_accept_quest(quest_id)</code>  <code>async</code>","text":"<p>Keep accepting a quest until it is in progress or the client disconnects.</p> <p>Parameters:</p> Name Type Description Default <code>quest_id</code> <code>int</code> <p>Identifier of the quest to accept.</p> required <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Exits once the quest is tracked or a failure is recorded.</p> Source code in <code>core\\commands\\quest_commands.py</code> <pre><code>@check_alive\nasync def ensure_accept_quest(self, quest_id: int) -&gt; None:\n    \"\"\"Keep accepting a quest until it is in progress or the client disconnects.\n\n    Args:\n        quest_id (int): Identifier of the quest to accept.\n\n    Returns:\n        None: Exits once the quest is tracked or a failure is recorded.\"\"\"\n    while self.quest_not_in_progress(quest_id) and self.is_still_connected():\n        await self.accept_quest(quest_id)\n        await self.sleep(1000)\n        if quest_id in self.bot.failed_get_quest_datas:\n            return\n</code></pre>"},{"location":"api/commands/#core.commands.QuestCommands.ensure_turn_in_quest","title":"<code>ensure_turn_in_quest(quest_id, item_id=-1, amount=1)</code>  <code>async</code>","text":"<p>Attempt to turn in a quest until it completes or the client disconnects.</p> <p>Parameters:</p> Name Type Description Default <code>quest_id</code> <code>int</code> <p>Identifier of the quest to complete.</p> required <code>item_id</code> <code>int</code> <p>Required item id for turn-in when applicable.</p> <code>-1</code> <code>amount</code> <code>int</code> <p>Quantity of the required item.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Stops when the quest leaves the progress list or fails.</p> Source code in <code>core\\commands\\quest_commands.py</code> <pre><code>@check_alive\nasync def ensure_turn_in_quest(self, quest_id: int, item_id = -1, amount = 1) -&gt; None:\n    \"\"\"Attempt to turn in a quest until it completes or the client disconnects.\n\n    Args:\n        quest_id (int): Identifier of the quest to complete.\n        item_id (int): Required item id for turn-in when applicable.\n        amount (int): Quantity of the required item.\n\n    Returns:\n        None: Stops when the quest leaves the progress list or fails.\"\"\"\n    while self.quest_in_progress(quest_id) and self.is_still_connected():\n        await self.turn_in_quest(quest_id, item_id,amount)\n        await self.sleep(1000)\n        if quest_id in self.bot.failed_get_quest_datas:\n            return\n    print(\"quest turned in:\", quest_id, item_id)\n</code></pre>"},{"location":"api/commands/#core.commands.QuestCommands.is_completed_before","title":"<code>is_completed_before(quest_id)</code>  <code>async</code>","text":"<p>Determine whether the quest has been completed previously.</p> <p>Parameters:</p> Name Type Description Default <code>quest_id</code> <code>int</code> <p>Identifier of the quest to inspect.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True when the server indicates prior completion.</p> Source code in <code>core\\commands\\quest_commands.py</code> <pre><code>@check_alive\nasync def is_completed_before(self, quest_id: int) -&gt; bool:\n    \"\"\"Determine whether the quest has been completed previously.\n\n    Args:\n        quest_id (int): Identifier of the quest to inspect.\n\n    Returns:\n        bool: True when the server indicates prior completion.\"\"\"\n    await self.turn_in_quest(quest_id)\n    while(self.is_still_connected()):\n        if self.is_completed_before_var is not None:\n            output = self.is_completed_before_var\n            # print(f\"{quest_id} is {self.is_green_quest_var}\")\n            self.is_completed_before_var = None\n            return output\n        else:\n            await self.sleep(100)\n    return False\n</code></pre>"},{"location":"api/commands/#core.commands.QuestCommands.is_green_quest","title":"<code>is_green_quest(quest_id)</code>  <code>async</code>","text":"<p>Check whether a quest is marked green (ready to turn in).</p> <p>Parameters:</p> Name Type Description Default <code>quest_id</code> <code>int</code> <p>Identifier of the quest to inspect.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True when the server reports the quest as green.</p> Source code in <code>core\\commands\\quest_commands.py</code> <pre><code>@check_alive\nasync def is_green_quest(self, quest_id: int) -&gt; bool:\n    \"\"\"Check whether a quest is marked green (ready to turn in).\n\n    Args:\n        quest_id (int): Identifier of the quest to inspect.\n\n    Returns:\n        bool: True when the server reports the quest as green.\"\"\"\n    await self.turn_in_quest(quest_id)\n    while(self.is_still_connected()):\n        if self.is_green_quest_var is not None:\n            output = self.is_green_quest_var\n            # print(f\"{quest_id} is {self.is_green_quest_var}\")\n            self.is_green_quest_var = None\n            return output\n        else:\n            await self.sleep(100)\n    return False\n</code></pre>"},{"location":"api/commands/#core.commands.QuestCommands.quest_in_progress","title":"<code>quest_in_progress(quest_id)</code>","text":"<p>Return True when the quest is present in the in-progress list.</p> Source code in <code>core\\commands\\quest_commands.py</code> <pre><code>def quest_in_progress(self, quest_id: int) -&gt; bool:\n    \"\"\"Return True when the quest is present in the in-progress list.\"\"\"\n    loaded_quest_ids = [loaded_quest[\"QuestID\"] for loaded_quest in self.bot.loaded_quest_datas]\n    return str(quest_id) in str(loaded_quest_ids)\n</code></pre>"},{"location":"api/commands/#core.commands.QuestCommands.quest_not_in_progress","title":"<code>quest_not_in_progress(quest_id)</code>","text":"<p>Return True when the quest is not currently tracked in progress.</p> Source code in <code>core\\commands\\quest_commands.py</code> <pre><code>def quest_not_in_progress(self, quest_id: int) -&gt; bool:\n    \"\"\"Return True when the quest is not currently tracked in progress.\"\"\"\n    loaded_quest_ids = [loaded_quest[\"QuestID\"] for loaded_quest in self.bot.loaded_quest_datas]\n    return str(quest_id) not in str(loaded_quest_ids)\n</code></pre>"},{"location":"api/commands/#core.commands.QuestCommands.register_quest","title":"<code>register_quest(questId)</code>  <code>async</code>","text":"<p>Register a quest for auto accept and complete system.</p> <p>Parameters:</p> Name Type Description Default <code>questId</code> <code>int</code> <p>Identifier of the quest to register.</p> required Source code in <code>core\\commands\\quest_commands.py</code> <pre><code>@check_alive\nasync def register_quest(self, questId: int):\n    \"\"\"Register a quest for auto accept and complete system.\n\n    Args:\n        questId (int): Identifier of the quest to register.\"\"\"\n    if questId not in self.bot.registered_auto_quest_ids:\n        self.bot.registered_auto_quest_ids.append(questId)\n        await self.ensure_accept_quest(questId)\n</code></pre>"},{"location":"api/commands/#core.commands.QuestCommands.turn_in_quest","title":"<code>turn_in_quest(quest_id, item_id=-1, qty=1)</code>  <code>async</code>","text":"<p>Submit quest completion requirements and leave combat if needed.</p> <p>Parameters:</p> Name Type Description Default <code>quest_id</code> <code>int</code> <p>Identifier of the quest to turn in.</p> required <code>item_id</code> <code>int</code> <p>Required item id for the submission.</p> <code>-1</code> <code>qty</code> <code>int</code> <p>Quantity of the required item.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Updates quest tracking state and delays for server processing.</p> Source code in <code>core\\commands\\quest_commands.py</code> <pre><code>@check_alive\nasync def turn_in_quest(self, quest_id: int, item_id: int = -1, qty: int = 1) -&gt; None:\n    \"\"\"Submit quest completion requirements and leave combat if needed.\n\n    Args:\n        quest_id (int): Identifier of the quest to turn in.\n        item_id (int): Required item id for the submission.\n        qty (int): Quantity of the required item.\n\n    Returns:\n        None: Updates quest tracking state and delays for server processing.\"\"\"\n    self.quest_to_check = quest_id\n    await self.bot.ensure_leave_from_combat()\n    self.bot.turn_in_quest(quest_id, item_id, qty)\n    await asyncio.sleep(1)\n</code></pre>"},{"location":"api/commands/#core.commands.UtilityCommands","title":"<code>UtilityCommands</code>","text":"<p>               Bases: <code>_CommandBase</code></p> <p>General-purpose helpers shared across categories.</p>"},{"location":"api/commands/#core.commands.UtilityCommands.is_valid_json","title":"<code>is_valid_json(s)</code>","text":"<p>Return True when the provided string parses as JSON.</p> Source code in <code>core\\commands\\utility_commands.py</code> <pre><code>def is_valid_json(self, s: str) -&gt; bool:\n    \"\"\"Return True when the provided string parses as JSON.\"\"\"\n    try:\n        json.loads(s)\n        return True\n    except json.JSONDecodeError:\n        return False\n</code></pre>"},{"location":"api/commands/#core.commands.UtilityCommands.rest","title":"<code>rest()</code>  <code>async</code>","text":"<p>Request the rest action from the server.</p> Source code in <code>core\\commands\\utility_commands.py</code> <pre><code>async def rest(self) -&gt; None:\n    \"\"\"Request the rest action from the server.\"\"\"\n    await self.send_packet(f\"%xt%zm%restRequest%1%%\")\n</code></pre>"},{"location":"api/commands/#core.commands.UtilityCommands.send_chat","title":"<code>send_chat(message)</code>  <code>async</code>","text":"<p>Send a zone chat message through the server packet API.</p> Source code in <code>core\\commands\\utility_commands.py</code> <pre><code>async def send_chat(self, message: str) -&gt; None:\n    \"\"\"Send a zone chat message through the server packet API.\"\"\"\n    await self.send_packet(f\"%xt%zm%message%{self.bot.areaId}%{message}%zone%\")\n</code></pre>"},{"location":"api/commands/#core.commands.UtilityCommands.send_packet","title":"<code>send_packet(packet)</code>  <code>async</code>","text":"<p>Send a raw packet to the server after validating connectivity.</p> Source code in <code>core\\commands\\utility_commands.py</code> <pre><code>async def send_packet(self, packet: str) -&gt; None:\n    \"\"\"Send a raw packet to the server after validating connectivity.\"\"\"\n    if not self.is_still_connected():\n        return\n    self.bot.write_message(packet)\n    await asyncio.sleep(0.5)\n</code></pre>"},{"location":"api/commands/#core.commands.UtilityCommands.sleep","title":"<code>sleep(milliseconds)</code>  <code>async</code>","text":"<p>Asynchronously sleep for the requested number of milliseconds.</p> Source code in <code>core\\commands\\utility_commands.py</code> <pre><code>@check_alive\nasync def sleep(self,  milliseconds: int) -&gt; None:\n    \"\"\"Asynchronously sleep for the requested number of milliseconds.\"\"\"\n    await asyncio.sleep(milliseconds/1000)\n</code></pre>"},{"location":"api/commands/#core.commands.UtilityCommands.stopBot","title":"<code>stopBot(msg='')</code>","text":"<p>Print a stop message and terminate the bot session.</p> Source code in <code>core\\commands\\utility_commands.py</code> <pre><code>def stopBot(self, msg: str = \"\") -&gt; None:\n    \"\"\"Print a stop message and terminate the bot session.\"\"\"\n    print(Fore.RED + msg + Fore.RESET)\n    print(Fore.RED + \"stop bot: \" + self.bot.player.USER + Fore.RESET)\n    self.bot.stop_bot()\n</code></pre>"}]}